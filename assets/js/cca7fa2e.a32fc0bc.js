(self.webpackChunkexperimenter_docs=self.webpackChunkexperimenter_docs||[]).push([[1267],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(f,o(o({ref:t},u),{},{components:n})):a.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1137:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return p}});var a=n(2122),r=n(9756),i=(n(7294),n(3905)),o={id:"fml-front-end-format",title:"Feature Manifest Language Front-end Format As YAML",slug:"/fml-front-end-format"},s=void 0,l={unversionedId:"deep-dives/specifications/fml-front-end-format",id:"deep-dives/specifications/fml-front-end-format",isDocsHomePage:!1,title:"Feature Manifest Language Front-end Format As YAML",description:"- Status: accepted",source:"@site/docs/deep-dives/specifications/fml-front-end-format.md",sourceDirName:"deep-dives/specifications",slug:"/fml-front-end-format",permalink:"/fml-front-end-format",editUrl:"https://github.com/mozilla/experimenter-docs/edit/main/docs/deep-dives/specifications/fml-front-end-format.md",tags:[],version:"current",frontMatter:{id:"fml-front-end-format",title:"Feature Manifest Language Front-end Format As YAML",slug:"/fml-front-end-format"},sidebar:"sidebar",previous:{title:"Nimbus FML command line interface",permalink:"/fml-cli"},next:{title:"Componentizing the Nimbus Feature Manifest",permalink:"/fml-imports-and-includes"}},c=[{value:"Context and problem statement",id:"context-and-problem-statement",children:[]},{value:"Decision drivers",id:"decision-drivers",children:[]},{value:"Decision outcome",id:"decision-outcome",children:[]},{value:"Examples",id:"examples",children:[{value:"JSON Example",id:"json-example",children:[]},{value:"YAML Example",id:"yaml-example",children:[]}]},{value:"Other considered options",id:"other-considered-options",children:[{value:"Option 1 - JSON",id:"option-1---json",children:[]},{value:"Option 2 - JavaScript/TypeScript",id:"option-2---javascripttypescript",children:[]}]},{value:"Additional considerations",id:"additional-considerations",children:[]}],u={toc:c};function p(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Status: accepted"),(0,i.kt)("li",{parentName:"ul"},"Deciders: @travis79, @jhugman, @teshaq, @k88hudson"),(0,i.kt)("li",{parentName:"ul"},"Date: 2021-10-26")),(0,i.kt)("h2",{id:"context-and-problem-statement"},"Context and problem statement"),(0,i.kt)("p",null,"In order to allow product teams to define experimentable application features, there needs to be a manifest file which defines these in a way that is understandable to the Nimbus ecosystem.  The feature manifest should define data types used in the application code to configure features. It should also be able to define a complete default configuration for each application feature."),(0,i.kt)("p",null,"The purpose of this document is to define the decision on the format of the feature manifest but not be a full specification of the schema or language of it."),(0,i.kt)("h2",{id:"decision-drivers"},"Decision drivers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It should not be onerous to write and maintain for a junior engineer or intern"),(0,i.kt)("li",{parentName:"ul"},"A single feature should be readable/guessable by a product owner or designer"),(0,i.kt)("li",{parentName:"ul"},"Once written, it should be easy to navigate and read, even if there are many features"),(0,i.kt)("li",{parentName:"ul"},"It should map easily to Kotlin, Swift (and Rust)"),(0,i.kt)("li",{parentName:"ul"},"No algebraic types"),(0,i.kt)("li",{parentName:"ul"},"No inheritance / polymorphism"),(0,i.kt)("li",{parentName:"ul"},"Defaults should be specifiable at the property level"),(0,i.kt)("li",{parentName:"ul"},"Defaults should be specifiable at the feature level"),(0,i.kt)("li",{parentName:"ul"},"Alignment with Desktop Nimbus which is already using a feature manifest, in the hopes that the schema can be shared between mobile and desktop eventually")),(0,i.kt)("h2",{id:"decision-outcome"},"Decision outcome"),(0,i.kt)("p",null,"The front-end format for the Nimbus manifests will follow the ",(0,i.kt)("a",{parentName:"p",href:"https://yaml.org/"},"YAML")," format."),(0,i.kt)("p",null,"Pros:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"More concise, and less likely to have errors due to formatting such as missing a bracket or comma"),(0,i.kt)("li",{parentName:"ul"},"Support for comments within the document"),(0,i.kt)("li",{parentName:"ul"},"A schema can be defined using JSONSchema for the purposes of validation"),(0,i.kt)("li",{parentName:"ul"},"YAML is a superset of JSON, so any existing JSON should be able to be parsed by the YAML parser"),(0,i.kt)("li",{parentName:"ul"},"JSON can be embedded within YAML"),(0,i.kt)("li",{parentName:"ul"},'Support for multiple documents within one file, so each feature could be a separate "document", simplifying and flattening the schema'),(0,i.kt)("li",{parentName:"ul"},"Ease of migration for Desktop from JavaScript objects to YAML objects")),(0,i.kt)("p",null,"Cons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Yet another data representation language to deal with"),(0,i.kt)("li",{parentName:"ul"},"Readability over other formats is marginal")),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,'To illustrate the YAML format, here is an example of the "homescreen" feature, first in JSON, then the same representation in YAML.'),(0,i.kt)("h3",{id:"json-example"},"JSON Example"),(0,i.kt)("p",null,"This example is only intended to illustrate the structure of the data, and not serve as an example of the suggested format. See the YAML example below for the suggested format."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-JSON"},'{\n  "enums": [\n    {\n      "name": "SectionId",\n      "doc": "The sections of the homescreen",\n      "variants": [\n        {\n          "name": "top-sites",\n          "doc": "The original frecency sorted sites"\n        },\n        {\n          "name": "jump-back-in",\n          "doc": "Jump back in section"\n        },\n        {\n          "name": "recently-saved",\n          "doc": "Tabs that have been bookmarked recently"\n        }\n      ]\n    }\n  ],\n  "objects": [],\n  "hints": {},\n  "features": [\n    {\n      "name": "homescreen",\n      "doc": "Represents the homescreen feature",\n      "props": [\n        {\n          "name": "sections-enabled",\n          "doc": "A map of booleans",\n          "type": {\n            "EnumMap": [\n              {\n                "Enum": "HomeScreenSection"\n              },\n              "Boolean"\n            ]\n          },\n          "default": {\n            "jump-back-in": false,\n            "recently-saved": false,\n            "top-sites": true\n          }\n        }\n      ],\n      "default": null\n    }\n  ]\n}\n\n')),(0,i.kt)("h3",{id:"yaml-example"},"YAML Example"),(0,i.kt)("p",null,"This example is meant to illustrate the concise format and readability of YAML."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-YAML"},'---\n# Define your enumerations here\nenums:\n  SectionId:\n    description: The sections of the homescreen\n    variants:\n      top-sites:\n        description: The original frecency sorted sites\n      jump-back-in:\n        description: Jump back in section\n      recently-saved:\n        description: Tabs that have been bookmarked recently\n# Define your features here\nfeatures:\n  homescreen:\n    description: Represents the homescreen feature\n    variables:\n      sections-enabled:\n        description: A map of booleans\n        variable_type: Map<Enum(SectionId), Boolean>\n        default: |\n          [\n            "top-sites": "true"\n            "jump-back-in": "false"\n            "recently-saved": "false"\n          ]\n    default: ~\n')),(0,i.kt)("h2",{id:"other-considered-options"},"Other considered options"),(0,i.kt)("h3",{id:"option-1---json"},"Option 1 - JSON"),(0,i.kt)("p",null,"JSON is still technically supported since YAML is a superset of JSON."),(0,i.kt)("h3",{id:"option-2---javascripttypescript"},"Option 2 - JavaScript/TypeScript"),(0,i.kt)("p",null,"JavaScript and TypeScript parser crates are harder to find and appear less supported in Rust, and using a full-blown javascript engine seems like overkill."),(0,i.kt)("h2",{id:"additional-considerations"},"Additional considerations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It should be easy to copy a winning branch of an experiment or rollout back into the feature manifest"),(0,i.kt)("li",{parentName:"ul"},"Reference to bundled text and icons should allow for multiple choice in the manifest"),(0,i.kt)("li",{parentName:"ul"},"An app may consist of multiple projects"),(0,i.kt)("li",{parentName:"ul"},"The format/schema/grammar of the feature manifest language should be documented in the nimbus-shared repo")))}p.isMDXComponent=!0}}]);